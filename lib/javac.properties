#
# Copyright (c) 1994-1995 by Sun Microsystems Inc.
#
# @(#)javac.properties	1.62 96/01/02
#

javac.err.internal=\
	Internal error.
javac.err.eof.in.comment=\
	Comment not terminated at end of input.
javac.err.eof.in.string=\
	String not terminated at end of input.
javac.err.newline.in.string=\
	String not terminated at end of line.
javac.err.invalid.char.constant=\
	Invalid character constant.
javac.err.unbalanced.paren=\
	Unbalanced parentheses.
javac.err.invalid.escape.char=\
	Invalid escape character.
javac.err.invalid.octal.number=\
	Invalid character in octal number.
javac.err.invalid.number=\
	Invalid character in number.
javac.err.funny.char=\
	Invalid character in input.
javac.err.float.format=\
	Invalid floating point format.
javac.err.overflow=\
	Numeric overflow.
javac.err.underflow=\
	Numeric underflow.
javac.err.token.expected=\
	'%s' expected.
javac.err.statement.expected=\
	Statement expected.
javac.err.type.expected=\
	Type expected.
javac.err.identifier.expected=\
	Identifier expected.
javac.err.class.expected=\
	'class' or 'interface' keyword expected.
javac.err.toplevel.expected=\
	Class or interface declaration expected.
javac.err.missing.term=\
	Missing term.
javac.err.else.without.if=\
	'else' without 'if'.
javac.err.catch.without.try=\
	'catch' without 'try'.
javac.err.finally.without.try=\
	'finally' without 'try'.
javac.err.try.without.catch.finally=\
	'try' without 'catch' or 'finally'.
javac.err.case.without.switch=\
	'case' outside switch statement.
javac.err.default.without.switch=\
	'default' outside switch statement.
javac.err.io.exception=\
	I/O error in %s.
javac.err.array.index.required=\
	Array index required.
javac.err.not.array=\
	[] can only be applied to arrays. It can't be applied to %s.
javac.err.array.dim.in.decl=\
	Can't specify array dimension in a declaration.
javac.err.array.dim.in.type=\
	Can't specify array dimension in a type expression.
javac.err.invalid.array.expr=\
	Array constants can only be used in initializers.
javac.err.invalid.array.init=\
	Invalid initializer for type %s.
javac.err.invalid.lhs.assignment=\
	Invalid left hand side of assignment.
javac.err.invalid.args=\
	Invalid arguments to %s.
javac.err.invalid.cast=\
	Invalid cast from %s to %s.
javac.err.invalid.instanceof=\
	Impossible for %s to be instance of %s.
javac.err.invalid.type.expr=\
	Invalid type expression.
javac.err.invalid.field.reference=\
	Attempt to reference field %s in a %s.
javac.err.no.such.field=\
	No variable %s defined in %s.
javac.err.no.field.access=\
	Variable %s in %s not accessible from %s.
javac.err.no.static.field.access=\
	Can't make a static reference to nonstatic variable %s in %s.
javac.err.ambig.field=\
	Reference to %s is ambiguous. It is defined in %s and %s.
javac.err.invalid.field=\
	Attempt to reference method %s in %s as an instance variable.
javac.err.assign.to.final=\
	Can't assign a value to a final variable: %s
javac.err.undef.var=\
	Undefined variable: %s
javac.err.var.not.initialized=\
	Variable %s may not have been initialized.
javac.err.access.inst.before.super=\
	Can't reference %s before the superclass constructor has been called.
javac.err.ambig.class=\
	Ambiguous class: %s and %s
javac.err.invalid.arg=\
	Invalid argument to %s.
javac.err.invalid.arg.type=\
	Invalid argument type %s for %s.
javac.err.invalid.length=\
	'length' applied to %s, which is not an array.
javac.err.invalid.constr.invoke=\
	Only constructors can invoke constructors.
javac.err.constr.invoke.not.first=\
	Constructor invocation must be the first thing in a method.
javac.err.invalid.method.invoke=\
	Can't invoke a method on a %s.
javac.err.undef.meth=\
	Method %s not found in %s.
javac.err.no.meth.access=\
	Method %s in %s is not accessible from %s.
javac.err.no.static.meth.access=\
	Can't make static reference to method %s in %s.
javac.err.invalid.protected.method.use=\
	Can't access protected method %s in %s. %s is not a subclass of the current class.
javac.err.invalid.protected.field.use=\
	Can't access protected field %s in %s. %s is not a subclass of the current class.
javac.err.invalid.method=\
	Reference to variable %s in %s as if it was a method.
javac.err.invalid.array.dim=\
	Invalid array dimension.
javac.err.ambig.constr=\
	Constructor is ambiguous: %s, %s
javac.err.explicit.cast.needed=\
	Incompatible type for %s. Explicit cast needed to convert %s to %s.
javac.err.incompatible.type=\
	Incompatible type for %s. Can't convert %s to %s.
javac.err.invalid.term=\
	Invalid term.
javac.err.abstract.class=\
	%s must be declared abstract. It does not define %s from %s.
javac.err.abstract.class.not.final=\
	%s must be declared abstract and not final. It does not define %s from %s.
javac.err.new.intf=\
	%s is an interface. It can't be instantiated.
javac.err.invoke.abstract=\
	Can't directly invoke abstract method %s in %s.
javac.err.unmatched.meth=\
	No method matching %s found in %s.
javac.err.unmatched.constr=\
	No constructor matching %s found in %s.
javac.err.forward.ref=\
	Can't make forward reference to %s in %s.
javac.err.array.dim.missing=\
	Array dimension missing.
javac.err.new.abstract=\
	%s is an abstract class. It can't be instantiated.
javac.err.label.not.found=\
	No label definition found for %s.
javac.err.invalid.break=\
	'break' must be in loop or switch.
javac.err.invalid.continue=\
	'continue' must be in loop.
javac.err.invalid.decl=\
	Invalid declaration.
javac.err.return.with.value=\
	'return' with value from %s.
javac.err.return.without.value=\
	'return' without value from %s.
javac.err.return.inside.static.initializer=\
	'return' inside static initializer.
javac.err.invalid.label=\
	Invalid label.
javac.err.return.required.at.end=\
	Return required at end of %s.
javac.err.duplicate.label=\
	Duplicate case label: %s
javac.err.switch.overflow=\
	Case label %s too large for 'switch' on %s
javac.err.const.expr.required=\
	Constant expression required.
javac.err.duplicate.default=\
	Duplicate 'default' label.
javac.err.not.supported=\
	'%s' not supported.
javac.err.return.with.value.constr=\
	'return' with value from constructor: %s
javac.err.package.repeated=\
	Only one package declaration allowed.
javac.err.class.multidef=\
	Class %s already defined in %s.
javac.err.class.multidef.import=\
	Class name %s clashes with imported class %s.
javac.err.final.meth.override=\
	Final methods can't be overriden. Method %s is final in %s.
javac.err.redef.return.type=\
	Method redefined with different return type: %s was %s
javac.err.override.static.meth=\
	Static methods can't be overridden. Method %s is static in %s.
javac.err.override.instance.method.static=\
        Instance methods can't be overridden by a static method.\nMethod %s is an instance method in %s.
javac.err.override.public=\
	Methods can't be overridden to be more private. Method %s is public in %s.
javac.err.override.protected=\
	Methods can't be overridden to be more private. Method %s is protected in %s.
javac.err.override.private=\
	Methods can't be overridden to be more private. Method %s is not private in %s.
javac.err.intf.constructor=\
	Interfaces can't have constructors.
javac.err.constr.modifier=\
	Constructors can't be native, abstract, static, synchronized, or final: %s
javac.err.intf.initializer=\
	Interfaces can't have static initializers.
javac.err.intf.modifier.method=\
	Interface methods can't be native, static, synchronized, final, private, or protected : %s
javac.err.intf.modifier.field=\
	Interface fields can't be private or protected: %s
javac.err.transient.meth=\
	Method %s can't be transient. Only variables can be transient.
javac.err.volatile.meth=\
	Method %s can't be volatile. Only variables can be volatile.
javac.err.static.modifier=\
	Static methods can't be abstract: %s
javac.err.invalid.meth.body=\
	Abstract and native methods can't have a body: %s
javac.err.var.modifier=\
	Variables can't be synchronized, abstract or native: %s
javac.err.transient.modifier=\
	Transient variables can't be final or static: %s
javac.err.initializer.needed=\
	Final variables must be initialized: %s
javac.err.meth.multidef=\
	Duplicate method declaration: %s
javac.err.meth.redef.rettype=\
	Methods can't be redefined with a different return type: %s was %s
javac.err.var.multidef=\
	Duplicate variable declaration: %s was %s
javac.err.intf.super.class=\
	Superclass of %s can't be an interface: %s
javac.err.cant.access.class=\
	Can't access %s. Only public classes and interfaces in other packages can be accessed.
javac.err.repeated.modifier=\
	Repeated modifier.
javac.err.super.is.final=\
	Can't subclass final classes: %s
javac.err.super.is.intf=\
	Can't subclass interfaces: %s
javac.err.cyclic.super=\
	Cyclic class inheritance.
javac.err.cyclic.intf=\
	Cyclic interface inheritance.
javac.err.not.intf=\
	%s must be an interface.
javac.err.final.intf=\
	Interfaces can't be final: %s
javac.err.intf.impl.intf=\
	An interface can't implement anything; it can only extend other interfaces.
javac.err.multiple.inherit=\
	Multiple inheritance is not supported.
javac.err.intf.repeated=\
	Interface %s repeated.
javac.err.class.format=\
	Invalid class file format: %s, %s
javac.err.no.meth.body=\
	Method %s requires a method body. Otherwise declare it as abstract.
javac.err.no.constructor.body=\
	Constructor %s requires a method body.
javac.err.void.inst.var=\
	Instance variables can't be void: %s
javac.err.invalid.method.decl=\
	Invalid method declaration; return type required.
javac.err.super.not.found=\
	Superclass %s of %s not found.
javac.err.intf.not.found=\
	Interface %s of %s not found.
javac.err.final.abstract=\
        Class %s can't be declared both abstract and final.
javac.err.void.argument=\
	Argument can't have type void: %s
javac.err.invalid.expr=\
	Invalid expression statement.
javac.err.catch.not.reached=\
	catch not reached.
javac.err.stat.not.reached=\
	Statement not reached.
javac.err.arithmetic.exception=\
	Arithmetic exception.
javac.err.generic=\
	%s
javac.err.public.class.file=\
	Warning: Public %s must be defined in a file called "%s".
javac.err.lose.precision=\
	Possible loss of precision. Use an explicit cast to convert %s to %s.
javac.err.duplicate.argument=\
	Variable '%s' is used twice in the argument list of this method.
javac.err.local.redefined=\
	Variable '%s' is already defined in this method.
javac.err.private.class=\
	Classes can't be private. Classes are always accessible within the current package.
javac.err.recursive.constr=\
	Recursive constructor invocation: %s.
javac.err.wrong.class=\
	File %s does not contain %s as expected, but %s. Please remove the file.
javac.err.class.not.found=\
	Class %s not found in %s.
javac.err.package.not.found=\
	Package %s not found in %s.
javac.err.invalid.throws=\
	Invalid exception %s in throws clause. The exception must be a subclass of an exception thrown by %s from %s.
javac.err.throws.not.throwable=\
	%s in throws clause must be a subclass of class java.lang.Throwable.
javac.err.throw.not.throwable=\
	Can't throw %s; it must be a subclass of class java.lang.Throwable.
javac.err.catch.not.throwable=\
	Can't catch %s; it must be a subclass of class java.lang.Throwable.
javac.err.initializer.exception=\
	Exception %s can't be thrown in initializer.
javac.err.cant.read=\
	Can't read: %s
javac.err.cant.write=\
	Can't write: %s
javac.err.fatal.error=\
	An error has occurred in the compiler; please file a bug report (java-bugs@java.sun.com).
javac.err.fatal.exception=\
	An exception has occurred in the compiler; please file a bug report (java-bugs@java.sun.com).
javac.err.uncaught.exception=\
	Exception %s must be caught, or it must be declared in the throws clause of this method.
javac.err.catch.not.thrown=\
	Exception %s is never thrown in the body of the corresponding try statement.
